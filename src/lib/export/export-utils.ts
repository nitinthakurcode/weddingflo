import * as XLSX from 'xlsx'
import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'

interface ExportData {
  company: {
    name: string
    logo_url?: string
  }
  client: {
    name: string
    wedding_date: string
  }
  guests: any[]
  hotels: any[]
  gifts: any[]
  vendors: any[]
  budget: any[]
  events: any[]
  timeline: any[]
  documents: any[]
}

export async function exportToExcel(data: ExportData): Promise<ArrayBuffer> {
  const workbook = XLSX.utils.book_new()

  // Cover sheet
  const coverSheet = XLSX.utils.aoa_to_sheet([
    [data.company.name],
    [],
    [`Wedding: ${data.client.name}`],
    [`Date: ${new Date(data.client.wedding_date).toLocaleDateString()}`],
    [],
    ['Generated by WeddingFlow Pro'],
    [`Export Date: ${new Date().toLocaleString()}`],
  ])
  XLSX.utils.book_append_sheet(workbook, coverSheet, 'Cover')

  // Guest List Sheet
  if (data.guests.length > 0) {
    const guestSheet = XLSX.utils.json_to_sheet(
      data.guests.map(g => ({
        'Serial #': g.serial_number,
        'Name': g.name,
        'Email': g.email || '',
        'Phone': g.phone || '',
        'Group': g.group || '',
        'RSVP': g.rsvp_status || 'pending',
        'Dietary': g.dietary_restrictions || '',
        'Plus One': g.plus_one ? 'Yes' : 'No',
        'Checked In': g.checked_in ? 'Yes' : 'No',
      }))
    )
    XLSX.utils.book_append_sheet(workbook, guestSheet, 'Guests')
  }

  // Hotels Sheet
  if (data.hotels.length > 0) {
    const hotelSheet = XLSX.utils.json_to_sheet(
      data.hotels.map(h => ({
        'Guest': h.guest_name,
        'Hotel': h.hotel_name || '',
        'Room': h.room_number || '',
        'Check-in': h.check_in_date ? new Date(h.check_in_date).toLocaleDateString() : '',
        'Check-out': h.check_out_date ? new Date(h.check_out_date).toLocaleDateString() : '',
      }))
    )
    XLSX.utils.book_append_sheet(workbook, hotelSheet, 'Hotels')
  }

  // Gifts Sheet
  if (data.gifts.length > 0) {
    const giftSheet = XLSX.utils.json_to_sheet(
      data.gifts.map(g => ({
        'Gift': g.gift_name,
        'From': g.from_name || '',
        'Status': g.delivery_status || 'pending',
        'Thank You': g.thank_you_sent ? 'Sent' : 'Pending',
      }))
    )
    XLSX.utils.book_append_sheet(workbook, giftSheet, 'Gifts')
  }

  // Vendors Sheet
  if (data.vendors.length > 0) {
    const vendorSheet = XLSX.utils.json_to_sheet(
      data.vendors.map(v => ({
        'Vendor': v.vendor_name,
        'Category': v.category,
        'Contact': v.contact_name || '',
        'Phone': v.phone || '',
        'Email': v.email || '',
        'Cost': v.cost ? `${v.cost}` : '',
        'Status': v.payment_status || 'pending',
      }))
    )
    XLSX.utils.book_append_sheet(workbook, vendorSheet, 'Vendors')
  }

  // Budget Sheet
  if (data.budget.length > 0) {
    const budgetSheet = XLSX.utils.json_to_sheet(
      data.budget.map(b => ({
        'Category': b.category,
        'Estimated': `${b.estimated_cost}`,
        'Actual': b.actual_cost ? `${b.actual_cost}` : '-',
        'Difference': b.actual_cost ? `${b.actual_cost - b.estimated_cost}` : '-',
        'Status': b.payment_status || 'pending',
      }))
    )
    XLSX.utils.book_append_sheet(workbook, budgetSheet, 'Budget')
  }

  // Timeline Sheet
  if (data.timeline.length > 0) {
    const timelineSheet = XLSX.utils.json_to_sheet(
      data.timeline.map(t => ({
        'Event': t.title,
        'Start Time': t.start_time,
        'Duration': `${t.duration_minutes} min`,
        'Location': t.location || '',
        'Notes': t.notes || '',
      }))
    )
    XLSX.utils.book_append_sheet(workbook, timelineSheet, 'Timeline')
  }

  // Generate buffer
  const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' })
  return buffer
}

export async function exportToPDF(data: ExportData): Promise<ArrayBuffer> {
  const doc = new jsPDF()

  // Header
  doc.setFontSize(20)
  doc.text(data.company.name, 15, 20)

  doc.setFontSize(16)
  doc.text(`Wedding: ${data.client.name}`, 15, 35)

  doc.setFontSize(12)
  doc.text(`Date: ${new Date(data.client.wedding_date).toLocaleDateString()}`, 15, 45)

  let yPosition = 60

  // Guest List Table
  if (data.guests.length > 0) {
    doc.setFontSize(14)
    doc.text('Guest List', 15, yPosition)
    yPosition += 10

    autoTable(doc, {
      head: [['Name', 'Email', 'RSVP', 'Checked In']],
      body: data.guests.map(g => [
        g.name,
        g.email || '',
        g.rsvp_status || 'pending',
        g.checked_in ? '✓' : '○',
      ]),
      startY: yPosition,
      styles: { fontSize: 9 },
    })

    yPosition = (doc as any).lastAutoTable.finalY + 15
  }

  // Budget Summary
  if (data.budget.length > 0) {
    if (yPosition > 250) {
      doc.addPage()
      yPosition = 20
    }

    doc.setFontSize(14)
    doc.text('Budget Summary', 15, yPosition)
    yPosition += 10

    autoTable(doc, {
      head: [['Category', 'Estimated', 'Actual', 'Status']],
      body: data.budget.map(b => [
        b.category,
        `${b.estimated_cost}`,
        b.actual_cost ? `${b.actual_cost}` : '-',
        b.payment_status || 'pending',
      ]),
      startY: yPosition,
      styles: { fontSize: 9 },
    })

    yPosition = (doc as any).lastAutoTable.finalY + 15
  }

  // Vendors
  if (data.vendors.length > 0) {
    if (yPosition > 250) {
      doc.addPage()
      yPosition = 20
    }

    doc.setFontSize(14)
    doc.text('Vendors', 15, yPosition)
    yPosition += 10

    autoTable(doc, {
      head: [['Vendor', 'Category', 'Contact', 'Cost']],
      body: data.vendors.map(v => [
        v.vendor_name,
        v.category,
        v.contact_name || '',
        v.cost ? `${v.cost}` : '-',
      ]),
      startY: yPosition,
      styles: { fontSize: 9 },
    })
  }

  // Footer on all pages
  const pageCount = (doc as any).internal.getNumberOfPages()
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i)
    doc.setFontSize(8)
    doc.text(
      `Page ${i} of ${pageCount} | Generated by WeddingFlow Pro`,
      doc.internal.pageSize.width / 2,
      doc.internal.pageSize.height - 10,
      { align: 'center' }
    )
  }

  return doc.output('arraybuffer')
}
