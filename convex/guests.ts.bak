import { v } from 'convex/values';
import { mutation, query } from './_generated/server';

/**
 * Get a guest by ID
 */
export const get = query({
  args: { guestId: v.id('guests') },
  handler: async (ctx, args) => {
    const guest = await ctx.db.get(args.guestId);
    if (!guest) throw new Error('Guest not found');
    return guest;
  },
});

/**
 * List guests for a client
 */
export const list = query({
  args: { clientId: v.id('clients') },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Not authenticated');

    const guests = await ctx.db
      .query('guests')
      .withIndex('by_client', (q) => q.eq('client_id', args.clientId))
      .collect();

    return guests;
  },
});

/**
 * Search guests by name
 */
export const search = query({
  args: {
    clientId: v.id('clients'),
    query: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Not authenticated');

    const results = await ctx.db
      .query('guests')
      .withSearchIndex('search_guests', (q) =>
        q.search('guest_name', args.query).eq('client_id', args.clientId)
      )
      .collect();

    return results;
  },
});

/**
 * Get guest by QR token
 */
export const getByQRToken = query({
  args: { token: v.string() },
  handler: async (ctx, args) => {
    const guest = await ctx.db
      .query('guests')
      .withIndex('by_qr_token', (q) => q.eq('qr_code_token', args.token))
      .first();

    return guest;
  },
});

/**
 * Get check-in statistics for a client
 */
export const getCheckInStats = query({
  args: { clientId: v.id('clients') },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Not authenticated');

    const allGuests = await ctx.db
      .query('guests')
      .withIndex('by_client', (q) => q.eq('client_id', args.clientId))
      .collect();

    const checkedInGuests = allGuests.filter((g) => g.checked_in);

    return {
      total: allGuests.length,
      checked_in: checkedInGuests.length,
      pending: allGuests.length - checkedInGuests.length,
      percentage: allGuests.length > 0 ? (checkedInGuests.length / allGuests.length) * 100 : 0,
    };
  },
});

/**
 * Create a new guest
 */
export const create = mutation({
  args: {
    company_id: v.id('companies'),
    client_id: v.id('clients'),
    serial_number: v.number(),
    guest_name: v.string(),
    phone_number: v.optional(v.string()),
    email: v.optional(v.string()),
    number_of_packs: v.number(),
    additional_guest_names: v.array(v.string()),
    mode_of_arrival: v.optional(v.string()),
    arrival_date_time: v.optional(v.number()),
    mode_of_departure: v.optional(v.string()),
    departure_date_time: v.optional(v.number()),
    relationship_to_family: v.optional(v.string()),
    guest_category: v.optional(v.string()),
    events_attending: v.array(v.string()),
    dietary_restrictions: v.array(v.string()),
    special_needs: v.optional(v.string()),
    seating_preferences: v.array(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Not authenticated');

    const now = Date.now();
    // Generate unique QR token
    const qrToken = `${args.client_id}-${args.serial_number}-${now}`;

    const guestId = await ctx.db.insert('guests', {
      company_id: args.company_id,
      client_id: args.client_id,
      serial_number: args.serial_number,
      guest_name: args.guest_name,
      phone_number: args.phone_number,
      email: args.email,
      number_of_packs: args.number_of_packs,
      additional_guest_names: args.additional_guest_names,
      mode_of_arrival: args.mode_of_arrival,
      arrival_date_time: args.arrival_date_time,
      mode_of_departure: args.mode_of_departure,
      departure_date_time: args.departure_date_time,
      relationship_to_family: args.relationship_to_family,
      guest_category: args.guest_category,
      events_attending: args.events_attending,
      dietary_restrictions: args.dietary_restrictions,
      special_needs: args.special_needs,
      seating_preferences: args.seating_preferences,
      qr_code_token: qrToken,
      qr_scan_count: 0,
      form_submitted: false,
      checked_in: false,
      created_at: now,
      updated_at: now,
    });

    return guestId;
  },
});

/**
 * Bulk create guests
 */
export const bulkCreate = mutation({
  args: {
    company_id: v.id('companies'),
    client_id: v.id('clients'),
    guests: v.array(
      v.object({
        serial_number: v.number(),
        guest_name: v.string(),
        phone_number: v.optional(v.string()),
        email: v.optional(v.string()),
        number_of_packs: v.number(),
        additional_guest_names: v.array(v.string()),
        guest_category: v.optional(v.string()),
        events_attending: v.array(v.string()),
      })
    ),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Not authenticated');

    const now = Date.now();
    const guestIds = [];

    for (const guest of args.guests) {
      const qrToken = `${args.client_id}-${guest.serial_number}-${now}`;

      const guestId = await ctx.db.insert('guests', {
        company_id: args.company_id,
        client_id: args.client_id,
        serial_number: guest.serial_number,
        guest_name: guest.guest_name,
        phone_number: guest.phone_number,
        email: guest.email,
        number_of_packs: guest.number_of_packs,
        additional_guest_names: guest.additional_guest_names,
        guest_category: guest.guest_category,
        events_attending: guest.events_attending,
        dietary_restrictions: [],
        seating_preferences: [],
        qr_code_token: qrToken,
        qr_scan_count: 0,
        form_submitted: false,
        checked_in: false,
        created_at: now,
        updated_at: now,
      });

      guestIds.push(guestId);
    }

    return { count: guestIds.length, guestIds };
  },
});

/**
 * Update guest information
 */
export const update = mutation({
  args: {
    guestId: v.id('guests'),
    guest_name: v.optional(v.string()),
    phone_number: v.optional(v.string()),
    email: v.optional(v.string()),
    number_of_packs: v.optional(v.number()),
    additional_guest_names: v.optional(v.array(v.string())),
    mode_of_arrival: v.optional(v.string()),
    arrival_date_time: v.optional(v.number()),
    mode_of_departure: v.optional(v.string()),
    departure_date_time: v.optional(v.number()),
    relationship_to_family: v.optional(v.string()),
    guest_category: v.optional(v.string()),
    events_attending: v.optional(v.array(v.string())),
    dietary_restrictions: v.optional(v.array(v.string())),
    special_needs: v.optional(v.string()),
    seating_preferences: v.optional(v.array(v.string())),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Not authenticated');

    const guest = await ctx.db.get(args.guestId);
    if (!guest) throw new Error('Guest not found');

    await ctx.db.patch(args.guestId, {
      ...(args.guest_name && { guest_name: args.guest_name }),
      ...(args.phone_number !== undefined && { phone_number: args.phone_number }),
      ...(args.email !== undefined && { email: args.email }),
      ...(args.number_of_packs !== undefined && { number_of_packs: args.number_of_packs }),
      ...(args.additional_guest_names && { additional_guest_names: args.additional_guest_names }),
      ...(args.mode_of_arrival !== undefined && { mode_of_arrival: args.mode_of_arrival }),
      ...(args.arrival_date_time !== undefined && { arrival_date_time: args.arrival_date_time }),
      ...(args.mode_of_departure !== undefined && { mode_of_departure: args.mode_of_departure }),
      ...(args.departure_date_time !== undefined && { departure_date_time: args.departure_date_time }),
      ...(args.relationship_to_family !== undefined && { relationship_to_family: args.relationship_to_family }),
      ...(args.guest_category !== undefined && { guest_category: args.guest_category }),
      ...(args.events_attending && { events_attending: args.events_attending }),
      ...(args.dietary_restrictions && { dietary_restrictions: args.dietary_restrictions }),
      ...(args.special_needs !== undefined && { special_needs: args.special_needs }),
      ...(args.seating_preferences && { seating_preferences: args.seating_preferences }),
      updated_at: Date.now(),
    });

    return args.guestId;
  },
});

/**
 * Delete a guest
 */
export const deleteGuest = mutation({
  args: { guestId: v.id('guests') },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Not authenticated');

    await ctx.db.delete(args.guestId);
    return { success: true };
  },
});

/**
 * Check in a guest
 */
export const checkIn = mutation({
  args: {
    guestId: v.id('guests'),
    checked_in_by: v.id('users'),
    location: v.optional(
      v.object({
        lat: v.number(),
        lng: v.number(),
      })
    ),
  },
  handler: async (ctx, args) => {
    const guest = await ctx.db.get(args.guestId);
    if (!guest) throw new Error('Guest not found');

    await ctx.db.patch(args.guestId, {
      checked_in: true,
      checked_in_at: Date.now(),
      checked_in_by: args.checked_in_by,
      checked_in_location: args.location,
      updated_at: Date.now(),
    });

    return args.guestId;
  },
});

/**
 * Update RSVP status
 */
export const updateRSVP = mutation({
  args: {
    guestId: v.id('guests'),
    form_submitted: v.boolean(),
    form_ip_address: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const guest = await ctx.db.get(args.guestId);
    if (!guest) throw new Error('Guest not found');

    await ctx.db.patch(args.guestId, {
      form_submitted: args.form_submitted,
      form_submitted_at: args.form_submitted ? Date.now() : undefined,
      form_ip_address: args.form_ip_address,
      updated_at: Date.now(),
    });

    return args.guestId;
  },
});

/**
 * Generate new QR code
 */
export const generateQRCode = mutation({
  args: { guestId: v.id('guests') },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Not authenticated');

    const guest = await ctx.db.get(args.guestId);
    if (!guest) throw new Error('Guest not found');

    const newToken = `${guest.client_id}-${guest.serial_number}-${Date.now()}`;

    await ctx.db.patch(args.guestId, {
      qr_code_token: newToken,
      qr_scan_count: 0,
      updated_at: Date.now(),
    });

    return newToken;
  },
});

/**
 * Record QR code scan
 */
export const recordQRScan = mutation({
  args: { guestId: v.id('guests') },
  handler: async (ctx, args) => {
    const guest = await ctx.db.get(args.guestId);
    if (!guest) throw new Error('Guest not found');

    await ctx.db.patch(args.guestId, {
      qr_scan_count: guest.qr_scan_count + 1,
      qr_last_scanned: Date.now(),
      updated_at: Date.now(),
    });

    return args.guestId;
  },
});
